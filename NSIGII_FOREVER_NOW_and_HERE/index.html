<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MMUKO-OS | Trident Protocol</title>
    <style>
        :root {
            --bg-color: #2C2A28;       /* Warm dark brown */
            --primary: #D48C45;        /* Vibrant copper/bronze */
            --secondary: #A68B5B;      /* Muted bronze */
            --accent: #B8860B;         /* Dark goldenrod */
            --text-light: #EAE6E1;     /* Warm off-white */
            --text-dark: #3D3B39;      /* Deep charcoal */
            --success: #00ff41;        /* Terminal Green */
            --fail: #ff3333;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; user-select: none; }

        body, html {
            width: 100%; height: 100%; overflow: hidden;
            background-color: var(--bg-color);
            font-family: 'Courier New', Courier, monospace;
            color: var(--text-light);
        }

        #mmukoCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; cursor: crosshair; }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 2; pointer-events: none; padding: 25px;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        header {
            pointer-events: auto; border-left: 4px solid var(--primary);
            padding-left: 15px; background: rgba(44, 42, 40, 0.9);
            backdrop-filter: blur(8px); width: fit-content;
        }

        .brand { font-size: 26px; font-weight: bold; letter-spacing: 2px; color: var(--primary); }
        .version { font-size: 12px; color: var(--secondary); margin-left: 10px; opacity: 0.7; }
        .subtitle { font-size: 11px; margin-top: 5px; letter-spacing: 1px; color: var(--secondary); }

        #boot-status-panel {
            position: absolute; top: 25px; right: 25px; width: 300px;
            background: rgba(30, 28, 26, 0.95); border: 1px solid var(--secondary);
            padding: 20px; pointer-events: auto; box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        .panel-header { border-bottom: 1px solid var(--accent); margin-bottom: 15px; padding-bottom: 8px; color: var(--accent); font-weight: bold; text-align: right; font-size: 14px; letter-spacing: 1px; }
        .stat-row { display: flex; justify-content: space-between; margin-bottom: 10px; font-size: 13px; }
        .label { color: var(--secondary); }
        .value { font-weight: bold; transition: color 0.3s ease; }
        .verified { color: var(--success); text-shadow: 0 0 10px var(--success); }

        #terminal-output {
            pointer-events: auto; width: 450px; height: 220px;
            background: rgba(0, 0, 0, 0.85); border: 1px solid var(--secondary);
            position: absolute; bottom: 25px; left: 25px; padding: 15px;
            overflow: hidden; font-size: 11px; color: var(--secondary);
            box-shadow: 0 -5px 20px rgba(0,0,0,0.4);
        }

        #logs { display: flex; flex-direction: column; height: 100%; overflow-y: auto; scrollbar-width: none; }
        .log-entry { margin-bottom: 5px; border-left: 2px solid #444; padding-left: 8px; line-height: 1.4; }
        .log-entry.phase { color: var(--primary); font-weight: bold; margin-top: 8px; border-left-color: var(--primary); text-transform: uppercase; }
        .log-entry.success { color: var(--success); }

        .scanline {
            width: 100%; height: 3px; background: rgba(212, 140, 69, 0.04);
            position: absolute; top: 0; left: 0; animation: scan 6s linear infinite; pointer-events: none; z-index: 10;
        }

        @keyframes scan { 0% { top: 0%; } 100% { top: 100%; } }

        .vignette {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 40%, rgba(0,0,0,0.4) 100%);
            pointer-events: none; z-index: 5;
        }
    </style>
</head>
<body>

    <canvas id="mmukoCanvas"></canvas>
    <div class="scanline"></div>
    <div class="vignette"></div>

    <div id="ui-layer">
        <header>
            <div class="brand">MMUKO-OS <span class="version">v1.0.0-NSIGII</span></div>
            <div class="subtitle">PROTOCOL: IDENTITY • DEVICE • TIME</div>
        </header>

        <div id="boot-status-panel">
            <div class="panel-header">AURA-SEAL COHERENCE</div>
            <div class="stat-row">
                <span class="label">BOOT STATE:</span>
                <span id="state-val" class="value">SPARSE</span>
            </div>
            <div class="stat-row">
                <span class="label">COHERENCE:</span>
                <span id="coherence-val" class="value">0.0%</span>
            </div>
            <div class="stat-row">
                <span class="label">ENTROPY:</span>
                <span id="entropy-val" class="value">9.99</span>
            </div>
            <div class="stat-row" style="margin-top: 15px; border-top: 1px solid #444; padding-top: 15px">
                <span class="label">P1 (IDENTITY):</span>
                <span id="p1-status" class="value">PENDING</span>
            </div>
            <div class="stat-row">
                <span class="label">P2 (DEVICE):</span>
                <span id="p2-status" class="value">PENDING</span>
            </div>
            <div class="stat-row">
                <span class="label">P3 (TIME):</span>
                <span id="p3-status" class="value">PENDING</span>
            </div>
        </div>

        <div id="terminal-output">
            <div id="logs"></div>
        </div>
    </div>

    <script>
        /**
         * VECTOR MATH LIBRARY
         */
        const Vec2 = function(x, y) { this.x = x; this.y = y; };
        Vec2.prototype.dist = function(v) {
            const dx = this.x - v.x, dy = this.y - v.y;
            return Math.sqrt(dx * dx + dy * dy);
        };
        Vec2.prototype.getAngle = function(center) {
            return Math.atan2(this.y - center.y, this.x - center.x);
        };

        /**
         * PIXEL BUFFER LIBRARY
         */
        function PixelBuffer(imageData) {
            this.data = imageData.data;
            this.width = imageData.width;
            this.height = imageData.height;
            this.buffer = new Uint32Array(this.data.buffer);
        }

        /**
         * APPLICATION CORE
         */
        const canvas = document.getElementById('mmukoCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        let width, height, centerX, centerY, pixelBuffer, imageData;

        const NSIGII_CODES = { YES: 0x55, NO: 0xAA, MAYBE: 0x00 };

        const state = {
            nodes: [
                { id: 'P1', angle: Math.PI / 2, target: 0, color: '#D48C45', label: 'IDENTITY', active: false },
                { id: 'P2', angle: Math.PI, target: (5 * Math.PI) / 4, color: '#A68B5B', label: 'DEVICE', active: false },
                { id: 'P3', angle: (3 * Math.PI) / 2, target: (7 * Math.PI) / 4, color: '#B8860B', label: 'TIME', active: false }
            ],
            ringRadius: 0,
            draggingNode: null,
            coherence: 0,
            entropy: 9.99,
            verified: false,
            bootPhase: 'SPARSE'
        };

        function init() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            centerX = width / 2;
            centerY = height / 2;
            state.ringRadius = Math.min(width, height) * 0.32;
            
            imageData = ctx.createImageData(width, height);
            pixelBuffer = new PixelBuffer(imageData);
            
            log("NSIGII Boot Protocol v1.0.0 Initiated.", "phase");
            log("Establishing Ring-Zone Topology...");
            log("Status: SPARSE - Resolve Interdependency Tree.");
        }

        function log(msg, type = "") {
            const logs = document.getElementById('logs');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
            logs.appendChild(entry);
            logs.scrollTop = logs.scrollHeight;
        }

        function updateProtocol() {
            let totalDelta = 0;
            state.nodes.forEach(node => {
                let a1 = (node.angle + Math.PI * 2) % (Math.PI * 2);
                let a2 = (node.target + Math.PI * 2) % (Math.PI * 2);
                let delta = Math.abs(a1 - a2);
                if (delta > Math.PI) delta = Math.PI * 2 - delta;
                
                const nodeCoherence = Math.max(0, 1 - (delta / 0.4)); // 0.4 rad tolerance
                node.active = nodeCoherence > 0.96;
                totalDelta += delta;
            });

            // Calculate overall system coherence
            // The magic threshold for NSIGII verification is 95.4%
            const avgCoherence = 1 - (totalDelta / (Math.PI * 1.2));
            state.coherence = Math.max(0, Math.min(100, avgCoherence * 100));
            state.entropy = Math.max(0, 9.99 * (1 - avgCoherence));

            document.getElementById('coherence-val').textContent = state.coherence.toFixed(1) + '%';
            document.getElementById('entropy-val').textContent = state.entropy.toFixed(2);
            
            state.nodes.forEach((n, i) => {
                const el = document.getElementById(`p${i+1}-status`);
                el.textContent = n.active ? 'ALIGNED' : 'PENDING';
                el.className = 'value ' + (n.active ? 'verified' : '');
            });

            if (state.coherence >= 95.4 && !state.verified) {
                state.verified = true;
                state.bootPhase = 'VERIFIED';
                document.getElementById('state-val').textContent = 'VERIFIED';
                document.getElementById('state-val').className = 'value verified';
                log("Aura-Seal Threshold Reached: 95.4%", "success");
                log("NSIGII VERIFIED [0x55]", "success");
                log("Welcome to MMUKO-OS. Breathe.", "phase");
            } else if (state.coherence < 95.4 && state.verified) {
                state.verified = false;
                state.bootPhase = 'ACTIVE';
                document.getElementById('state-val').textContent = 'ACTIVE';
                document.getElementById('state-val').className = 'value';
                log("Coherence Lost. Re-aligning Tridents...", "phase");
            }
        }

        function draw() {
            // 1. Aura Seal Noise Field
            const noiseIntensity = state.verified ? 4 : Math.floor(state.entropy * 22);
            const bgColor = 0xFF2C2A28; 
            
            for (let i = 0; i < pixelBuffer.buffer.length; i++) {
                if (Math.random() < (state.verified ? 0.02 : 0.12)) {
                    const val = Math.random() * noiseIntensity;
                    // ABGR: 0xAA BB GG RR
                    const r = 44 + val;
                    const g = 42 + val;
                    const b = 40 + val;
                    pixelBuffer.buffer[i] = (0xFF << 24) | (b << 16) | (g << 8) | r;
                } else {
                    pixelBuffer.buffer[i] = bgColor;
                }
            }
            ctx.putImageData(imageData, 0, 0);

            // 2. Ring Topology
            ctx.beginPath();
            ctx.arc(centerX, centerY, state.ringRadius, 0, Math.PI * 2);
            ctx.strokeStyle = state.verified ? 'rgba(0, 255, 65, 0.4)' : 'rgba(166, 139, 91, 0.25)';
            ctx.lineWidth = 1;
            ctx.setLineDash([10, 5]);
            ctx.stroke();
            ctx.setLineDash([]);

            // 3. Trident Nodes
            state.nodes.forEach(node => {
                const x = centerX + Math.cos(node.angle) * state.ringRadius;
                const y = centerY + Math.sin(node.angle) * state.ringRadius;

                // Connection Vector
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(x, y);
                ctx.strokeStyle = node.active ? 'rgba(0, 255, 65, 0.6)' : node.color;
                ctx.globalAlpha = 0.5;
                ctx.lineWidth = node.active ? 2 : 1;
                ctx.stroke();
                ctx.globalAlpha = 1.0;

                // Outer Glow for Active Nodes
                if (node.active) {
                    ctx.beginPath();
                    ctx.arc(x, y, 18, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(0, 255, 65, 0.2)';
                    ctx.fill();
                }

                // Node Body
                ctx.beginPath();
                ctx.arc(x, y, 12, 0, Math.PI * 2);
                ctx.fillStyle = node.active ? '#00ff41' : node.color;
                ctx.fill();
                ctx.strokeStyle = '#EAE6E1';
                ctx.lineWidth = 1;
                ctx.stroke();

                // ID Label
                ctx.fillStyle = '#EAE6E1';
                ctx.font = 'bold 11px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText(node.id, x, y + 28);
            });

            // 4. Center Sigil (The Nexus)
            ctx.beginPath();
            ctx.arc(centerX, centerY, 6, 0, Math.PI * 2);
            ctx.fillStyle = state.verified ? '#00ff41' : '#D48C45';
            ctx.fill();
            if (state.verified) {
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#00ff41';
                ctx.strokeStyle = '#00ff41';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.shadowBlur = 0;
            }

            updateProtocol();
            requestAnimationFrame(draw);
        }

        // Handle Interactions
        window.addEventListener('mousedown', (e) => {
            const mouse = new Vec2(e.clientX, e.clientY);
            state.nodes.forEach(node => {
                const nx = centerX + Math.cos(node.angle) * state.ringRadius;
                const ny = centerY + Math.sin(node.angle) * state.ringRadius;
                if (mouse.dist(new Vec2(nx, ny)) < 35) {
                    state.draggingNode = node;
                }
            });
        });

        window.addEventListener('mousemove', (e) => {
            if (state.draggingNode) {
                const mouse = new Vec2(e.clientX, e.clientY);
                state.draggingNode.angle = mouse.getAngle({x: centerX, y: centerY});
            }
        });

        window.addEventListener('mouseup', () => state.draggingNode = null);
        window.addEventListener('resize', init);

        // Start
        init();
        draw();
    </script>
</body>
</html>
